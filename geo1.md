Thanks for the clarification. I’ll investigate what might be causing the 'Export Error' when trying to generate and share a DA 2062 export as a PDF using your app, which appears to involve custom logic. I’ll look into possible format issues, encoding problems, or rendering faults that would consistently cause this export to fail.

I’ll get back to you with insights and recommendations shortly.


# Diagnostic Report: DA 2062 PDF Export Error on iOS

## Issue Overview

When attempting to export a DA Form 2062 as a PDF on an iOS app (iPhone 16 Pro, iOS 18.4), the app consistently displays an **“Export Error”** with the message: **“The data couldn’t be read because it isn’t in the correct format.”** This occurs regardless of which property items are selected or which recipient is chosen. The error suggests a data formatting or parsing issue during the export process, likely related to how the app generates or handles the PDF data. Below we investigate potential causes in the JSON data handling, PDF generation logic, data format inconsistencies, and signature/attachment serialization. We then provide recommendations to resolve the error.

## JSON Encoding/Decoding Issues

One probable cause is a **mismatch in JSON format between the server and client**, leading to JSON parsing failures on the iOS side. The error message (“data couldn’t be read… incorrect format”) is typical of a `JSONDecoder` failure in Swift. Key points to consider:

* **Response JSON vs. Client Model Mismatch:** The server returns a JSON response containing a `document` object (with metadata about the generated hand receipt). However, if the structure or types in this JSON don’t exactly match the Swift `Document` model, decoding will fail. For example, the backend’s `Document` includes fields like `propertyId`, `attachments`, etc.. If the Swift model marks these differently (wrong type or not optional when the JSON can be `null`), decoding triggers an error. A known issue is the **Attachments field**: the backend serializes `attachments` as a JSON string containing an array (i.e. a string of the form `"[\"url1\", \"url2\"]"`), whereas the iOS client likely expects an array type.

* **Double-encoded Attachments:** In the server code, when a PDF is generated for in-app delivery, a presigned URL for the PDF file is put into an array and then marshaled to JSON, but stored as a string in the `attachments` field. As a result, the JSON response might include something like `"attachments": "[\"https://...signed_url...\"]"` (a string) instead of an actual JSON array. If the Swift `Document` model defines `attachments` as an array of strings (`[String]`) or similar, the `JSONDecoder` will be unable to decode the string into an array, raising a format error. This is a strong candidate for the error: the data is technically valid JSON, but **not in the format the decoder expects**, hence “isn’t in the correct format.” The decoding code on iOS illustrates that it expects to parse the `"document"` key into a `Document` struct, which would fail if any field is improperly formatted.

* **Optional vs Non-Optional Fields:** The server may omit or set `null` for fields like `propertyId` or `description` (for example, when multiple items are exported, `propertyId` is `null` in JSON). If the Swift model isn’t using optionals for these fields, the decoder will throw a type mismatch error (e.g. expecting an `Int` but found `nil`). This would also yield the generic format error. Ensuring the Swift model uses optional types for any field that can be null (e.g. `propertyId`, `description`, `readAt`) is crucial.

* **Date Format Misalignment:** The backend likely returns timestamps (such as `sentAt`, `createdAt`) as ISO8601 strings by default (e.g. `"2025-06-06T17:45:51Z"`). If the `Document` model in Swift uses a `Date` type for these, `JSONDecoder` needs a matching date decoding strategy (e.g. `.iso8601`). If not set, the decoder will not know how to parse the date string, leading to a decoding failure. In the absence of a custom strategy, a date string in JSON is “not the correct format” for a Swift `Date` property. This could be another factor if the model wasn’t configured for date decoding.

* **Request JSON Structure:** On the encoding side (when the app sends the export request), any improper JSON structure could also cause server-side errors. The request payload includes lists of property IDs, user info, etc., which the app encodes with `JSONEncoder`. If, for instance, a property ID or user ID isn’t encoded as the expected type, the server might respond with a parsing error. However, in this case the server is indeed processing the request and returning a response (HTTP 201), so the request JSON is likely okay. The issue occurs when reading the response on iOS. Still, it’s worth ensuring the request uses the correct keys and types (the Swift `GeneratePDFRequest` uses coding keys that match the server (`property_ids`, `from_user`, etc.), which seems correct).

**Why this matters:** Swift’s decoding is strict about types. A single mis-typed field (e.g. a string where an object or array was expected) will cause a `.dataCorrupted` or `.typeMismatch` error internally. The user sees only the generic “data couldn’t be read” message unless the app catches and handles the error. In our case, the code simply throws the error, which surfaces this generic message to the UI. Thus, addressing JSON format mismatches is critical.

## PDF Generation Logic Issues

Although the error text suggests a format/parsing issue (rather than a typical PDF rendering issue), we should also examine the **custom PDF generation logic** for potential problems. The DA 2062 PDF is generated by custom code (server-side Go using a PDF library) and then delivered to the app. Potential areas of concern include:

* **Validity of Generated PDF:** The backend uses a library (e.g. `gofpdf`) to construct the PDF. If the PDF content were somehow corrupted or not properly formed, an attempt to handle that PDF data on iOS could fail. For example, if the app tried to initialize an iOS PDF viewer or `PDFDocument` with invalid data, it might result in an “incorrect format” error. However, in this workflow the app is not directly parsing the PDF bytes (the error arises before any viewer is shown). The PDF generation step on the server appears to succeed (the server returns status 201 Created, not an error), so the PDF file itself is likely well-formed.

* **Content-Type and Response Handling:** The export endpoint has dual behaviors – it can return JSON (for in-app delivery) or raw PDF data (for direct download) depending on parameters. If the app were misidentifying the response type, it could, for instance, treat a PDF binary response as JSON. That would definitely trigger a “data isn’t in correct format” error (since parsing PDF bytes as JSON would fail). In our case, when exporting to a connected recipient (in-app hand receipt), the server correctly returns JSON (status 201). For a direct “Download PDF” scenario, the server would return `Content-Type: application/pdf` with status 200 and raw PDF bytes. It’s important that the client code differentiate these cases. The current iOS implementation checks the HTTP status code: it expects 201 for the in-app JSON response, and presumably would handle a 200 differently. If that logic were flawed (e.g. expecting JSON when a PDF stream comes back), the format error would occur. Ensuring that the app’s network layer uses the appropriate handling (e.g. if status == 200 and content-type is PDF, handle as file data, otherwise decode JSON) is vital.

* **Custom Rendering on iOS:** If there is any client-side PDF rendering (for example, if the app tries to generate or modify the PDF after receiving data), that could introduce errors. From the design, PDF generation is done on the backend, but if offline or for preview the app might use iOS PDFKit or `UIGraphicsPDFRenderer`. If any such custom rendering logic is present, it should be checked for correctness. Common pitfalls include misusing PDF context APIs or corrupting the PDF data stream. In this scenario, however, since the error occurs during the export request/response, it’s more likely tied to data format rather than drawing commands.

**Summary:** The PDF generation process itself does not appear to throw an error (no “Failed to generate PDF” message from the server). The “Export Error” arises when handling the output. Thus, while the PDF library (gofpdf) should be kept up-to-date and its output validated, the focus should be on how the PDF’s metadata and data are transmitted to the app, rather than the drawing of the PDF content.

## Data Format Inconsistencies in Property/User Data

Inconsistencies or edge cases in the data content could also lead to format errors if not handled properly. We should verify that **all property and user fields are formatted in ways both the backend and iOS expect**. Relevant considerations include:

* **Unexpected Characters or Encoding:** Property names, unit names, or other text fields might contain characters (e.g. ampersands, quotes, non-ASCII characters) that need proper encoding. JSON encoding (via `JSONEncoder/Decoder` and Go’s `encoding/json`) will escape special characters as needed, so this usually isn’t a direct cause of a parsing error (the JSON remains valid). However, if any field contains a character that isn’t properly escaped, it could break the JSON format. This is unlikely with standard libraries, but worth ensuring (for instance, verify that all text fields are strings in JSON and that no binary data sneaks in unencoded).

* **Numeric vs String Mismatch:** All IDs (userID, propertyID, etc.) should be numeric in JSON. If somehow a number is sent as a string (or vice versa), decoding will fail. For example, `senderUserId` is an unsigned int on the backend and should appear as a number in JSON. If the Swift model expected a `String` for these IDs, or if the JSON accidentally quoted the number, that’s a mismatch. Similarly, enumerated fields like `type` and `status` are strings (e.g. `"transfer_form"`, `"unread"`). The Swift side might use an enum or constants for these. We should ensure the raw values match exactly. A typo or case difference (e.g. expecting `DocumentTypeTransferForm = "TRANSFER_FORM"` vs receiving `"transfer_form"`) would cause decoding to fail or produce `nil` which may not be handled.

* **Date/Time Formats:** As mentioned, the `sentAt`, `createdAt`, `updatedAt` fields are likely ISO8601 timestamps in the JSON. The Swift decoder by default doesn’t auto-parse ISO strings into `Date` unless configured. If the `Document` model has these as `String`, then it’s fine (they’ll just be stored as-is). But if they are `Date`, the app must specify `JSONDecoder.dateDecodingStrategy = .iso8601` (or a custom formatter) before decoding. An inconsistency here (e.g. treating a date string as a Date without proper decoding rules) will throw a decoding error. Given iOS 18.4 context, it’s possible newer Swift versions might have improved handling, but explicit strategy is still required for ISO strings.

* **Missing or Additional Fields:** The backend’s JSON for `document` may include nested objects or omit certain fields based on `omitempty`. For instance, the `sender` and `recipient` sub-objects (with user details) are marked as `omitempty`. If the server included them (e.g. preloaded user data), the JSON would have a nested `sender` object. If the Swift `Document` model doesn’t have a corresponding nested struct or `sender` property, the decoder will ignore it (which is fine). Extra fields in JSON that have no matching Swift property are ignored by default – they *do not* cause an error. However, missing required fields do cause an error. If the Swift model treats something as non-optional that the server omitted, that’s effectively a missing field scenario. We should audit the Swift `Document` model to ensure all its non-optional properties always appear in the JSON. For example, if `attachments` was non-optional `[String]` in Swift, but the server sometimes omits `attachments` (when there are none, it might be `null` or not present), that’s a problem. The safe route is to make such fields optional.

* **Consistent Use of JSON Keys:** The coding keys should match exactly between client and server. The server uses camelCase JSON keys (e.g. `"recipientUserId"`, `"signature_url"` inside user info). Swift’s `Codable` will, by default, expect property names that match exactly (including case) unless coding keys are provided or a key decoding strategy (like convertFromSnakeCase) is set. We see that the Swift request model uses custom CodingKeys to match snake\_case for the request body, but for the response `Document`, hopefully keys match (likely camelCase in the Swift model as well). A mismatch like using `signatureUrl` vs `signatureURL` in Swift without a CodingKey could cause the decoder to not find the key and throw a `.keyNotFound` error. All these need to be reviewed.

In summary, any inconsistency between what the backend sends and what the client expects can result in a parsing error. Given that the error happens consistently for all inputs, it points to a systemic format mismatch (like the attachments or a field type) rather than a one-off bad data value.

## Signature Image & Attachment Serialization

Handling of **signature images and attachments** is another area to investigate, as it involves encoding binary or external data references, which can easily lead to format issues if done incorrectly:

* **Signature URL Handling:** The app includes a signature URL for the current user (and potentially would handle the recipient’s signature) when generating the PDF. On iOS, this `signatureUrl` is likely a file URL or a data URL saved in user defaults for the user’s signature image. The client sends this URL string in the JSON request (`from_user.signature_url`). The server then attempts to use it when generating the PDF: the Go PDF generator code tries to download the image from the provided `SignatureURL`. If the URL is a local file path (e.g. `file:///var/mobile/Containers/.../signature.png`), the server obviously cannot reach it. The PDF generator logs a failure to download in that case but does **not** abort the PDF creation – it just skips that signature image (so the PDF is generated without that signature). This scenario wouldn’t cause a JSON error, but it means the signature isn’t appearing on the PDF. The fix would be to ensure the signature is uploaded to a server-accessible location. For instance, the user’s signature should be stored in the backend (and `SignatureURL` should point to a cloud storage URL or API endpoint). In the meantime, if `signatureUrl` is invalid, it might be better for the app not to send it (let the server fall back to any stored signature on file, as the code does). While this won’t fix the export error, it’s an important consistency to address to meet user expectations for signatures.

* **Attachment Field Serialization:** As discussed, the `attachments` field in the `Document` record is meant to hold an array of file URLs (in this context, the PDF file URL for the generated form). Internally, the server stores this in a JSONB column and in Go it’s represented as a `*string` containing JSON. The server code takes the array of URLs and marshals it into a JSON string before saving/returning. This double-encoding is likely problematic for the client. Ideally, the attachments should be an actual JSON array in the API response, not a string. In other words, the API response should look like `"attachments": ["https://..."]` rather than `"attachments": "[\"https://...\"]"`. The incorrect format currently requires the client to decode a string then parse JSON inside it, which `Codable` won’t do automatically. If the Swift model expected `attachments: [String]`, it will error on encountering a string. If it expected `String`, it would get the whole JSON text as one string (no error) – but then the app would have to manually decode that string to get the array, which is clunky. Most likely, the intention was to use an array.

* **Impact of Attachments on Export Flow:** In the in-app export flow (to a recipient), the PDF file is uploaded to cloud storage and its URL is placed in the `attachments`. The server then creates a `Document` record and returns it to the sender with a success message. The receiver can later retrieve this record and use the URL to download the PDF. The sender’s app doesn’t necessarily need to use the URL. Therefore, one workaround could be to **ignore the attachments field on the sender side**. If the Swift `Document` model did not even include an `attachments` property, the decoder would ignore that JSON key and succeed (since extra keys are allowed). The fact that we see a failure implies the app is trying to decode it. It may be beneficial for the client to simply exclude or ignore attachments in this response, since the sender might not need to use the URL. The focus for the sender is likely just the confirmation message. However, if the app will display the sent hand-receipt in a “Sent documents” list, it will need to parse attachments properly.

* **Serialization of Other Attachments (if any):** While DA 2062 export likely only deals with the PDF file itself as an attachment, any similar serialization (like if multiple images or files were attached to forms) should be done consistently. The same principle applies: the API should return arrays/objects, not JSON-in-strings, and the client should be ready to decode them. If any part of the system encodes complex data as JSON strings (sometimes done to easily store in a text column), it’s better to decode that on the server side and send a proper JSON structure to the app.

In short, **the attachment serialization is a prime suspect for the format error.** Fixing it will likely resolve the decoding issue. Additionally, proper handling of signature images (ensuring the server has a valid image URL or the app doesn’t send an unusable one) will improve the overall PDF output, though it’s not the direct cause of the crash.

## Recommendations and Fixes

To address the consistent export error and ensure PDF exports work smoothly, we recommend the following actions:

**1. Align JSON Models Between Server and Client:** Audit the Swift `Document` struct against the server’s `Document` JSON structure. For each field:

* Ensure the data type matches (e.g. `attachments` should be an array of `String` if the server sends an array, or make it `String` if the server continues to send a JSON string – the former is preferable).
* Mark fields optional in Swift if they can be null/missing in JSON (e.g. `propertyId`, `description`, `readAt`, `attachments` should likely be optional).
* Add CodingKeys or adjust property names in Swift to exactly match JSON keys (e.g. if Swift uses `senderUserID` vs JSON `senderUserId`, fix via `enum CodingKeys` or renaming).
* Remove or ignore fields that the app doesn’t use. If the attachments field is not immediately needed on the sending side, you could omit it from the Swift model to avoid parsing it (unknown keys will be ignored by `JSONDecoder`). This can be a temporary measure until the API is fixed to send the proper type.

**2. Fix Attachment Serialization on the Backend:** It’s best to correct the API to return a true JSON array for `attachments`. Since the backend already marshals the array to a JSON string, a fix could be:

* Change the `Document.Attachments` field in Go to a concrete slice type (e.g. `[]string` with proper JSON tags) so that encoding it produces a JSON array. GORM can still store it in JSONB, and `encoding/json` will output an array structure. This would eliminate the double encoding.
* Alternatively, post-process the `doc` before responding: unmarshal the `Attachments` string into an array and put that into the response. For example, build the response like `c.JSON(201, gin.H{"document": doc, "document":{"attachments": attachmentsArr, ...}})`. However, this is a bit hacky – adjusting the model is cleaner.
* Ensure consistency for all similar cases (if any other API fields are stored as JSON strings).

Once the server returns `"attachments": [...]` (array), update the Swift model `attachments: [String]?` accordingly. The decoding should then work without error.

**3. Enhance JSON Decoding Robustness on iOS:** Even with perfect alignment, decoding can fail if something unexpected comes along. It’s good practice to handle errors gracefully:

* Use `do-catch` when calling `JSONDecoder.decode`. If a `DecodingError` is caught, log or inspect the error (`error.localizedDescription` and the associated context) to pinpoint which field caused it. For instance, a DecodingError might say **“Expected to decode Array<…> but found a string/data instead”**, confirming the attachments issue. This information can be used in debugging and to show a more user-friendly message.
* Provide the user a friendly alert if parsing fails (e.g. “Failed to parse export data. Please try again later.”) rather than the generic system message.
* Consider using `JSONDecoder.keyDecodingStrategy` or `dateDecodingStrategy` if needed. For example, if you prefer snake\_case in Swift property names, you can use `.convertFromSnakeCase` to automatically map JSON keys. In this project, it’s probably easier to explicitly match the keys via CodingKeys as has been done in some places.
* Set `decoder.dateDecodingStrategy = .iso8601` when decoding date fields, if you have `Date` properties. This will allow decoding ISO8601 timestamp strings into `Date` objects. Make sure the format matches (Go’s default `time.Time` JSON is RFC3339, which is compatible with ISO8601 format used by Foundation’s parser).

**4. Verify PDF Response Handling:** Double-check the logic for handling the export response:

* In the **“Send PDF to connection”** flow, the app expects JSON (status 201). We’ve addressed making sure this JSON can be decoded.
* In the **“Download PDF”** flow (if the app implements it), ensure the app does not attempt JSON decoding. Instead, when a 200 OK with content-type `application/pdf` is returned, handle it by saving the data or presenting a preview. The code could check `if response.mimeType == "application/pdf"` or use the absence of a `"document"` key to determine that raw PDF was returned. Currently, the code seems to throw a generic error on any status != 201 – you may need a separate path for status 200. For example, you could create a different API call function for “downloadPDF” that expects `Data` instead of decoding JSON. This separation can prevent format confusion.
* Test the “Download PDF” scenario (if available) to ensure no similar error occurs. The user should be able to receive the PDF file. You might allow them to share it or open it with an iOS PDF viewer. Using **QuickLook (QLPreviewController)** or **PDFKit’s PDFView** are good options to display the PDF on device once you have the `Data`.

**5. Address the Signature Image Workflow:** To avoid missing signatures:

* If the user’s signature is stored only locally, consider providing an upload mechanism so the backend has it (e.g. upload the signature image to the server when the user creates or updates their profile). The `SignatureURL` in the database can then point to a cloud URL (as seen in the backend User model). In our case, the backend does try to fall back to `fromUser.SignatureURL` from the DB if the request’s `signatureUrl` is empty. So ensuring the server has a copy of the signature will allow it to embed it in the PDF. Until then, if the app has a local signature but it isn’t uploaded, it may be better not to send a `file://` URL (the server can’t use it). Instead, send `nil` and let the server use whatever is on file (or leave it blank).
* For the recipient’s signature, the code sets `toUser.signatureUrl = nil` by default. If you plan to include recipient signatures, you’d need a similar approach (i.e. store and retrieve via server). This doesn’t directly affect the export error, but it’s part of the feature completeness.

**6. Testing and Validation:** After making the above changes, thoroughly test the export on a variety of cases:

* Different numbers of selected properties (including single and multiple items).
* Various recipients, including sending to oneself if that’s allowed (toUserId = 0 path, which triggers the PDF download response).
* Ensure that in all cases the iOS app no longer crashes or shows the format error. Instead, it should either show a success confirmation or handle the PDF file appropriately (e.g. open a preview or confirm email sent).
* Check the actual PDF content: verify unit info, selected items, and signatures appear as expected on the PDF document. This ensures that the data passed (unit names, user titles, etc.) are all handled without format issues on the PDF as well.

**7. Swift & iOS SDK Guidance:** Finally, leverage iOS frameworks for any future enhancements:

* If at some point local PDF generation is needed (say, for offline mode), you can use **UIGraphicsPDFRenderer** or **PDFKit** to create PDF files on device. Apple’s SDK handles a lot of formatting details, but you must still ensure data is in the correct format (e.g. images as `UIImage`, text as `String`).
* To present or share the PDF received from the server, consider using a **UIDocumentInteractionController** or **QLPreviewController**. This way you don’t need to manually parse PDF data – you let the system display it. Just be sure the data you feed it is exactly the PDF bytes from the server (no transformations needed if the server already created a PDF).
* Continue to use `Codable` for JSON as it simplifies parsing, but remain cautious about schema changes. If the backend changes, update the client model correspondingly. For instance, if more fields are added to the document JSON, you can ignore them if unneeded, or map them if they are relevant to the app (thanks to `Codable`’s flexibility, unknown fields are safely ignored).

By implementing these fixes and best practices, the **“incorrect format”** error should be resolved. The iOS app will successfully parse the export response and proceed with sending or saving the PDF. In turn, users will be able to generate DA 2062 hand receipt PDFs without encountering the export error, and all data (including attachments and signatures) will be handled in a robust, compatible way.

## Sources

* Excerpt from backend handler showing PDF URL attachment being JSON-encoded as a string. This highlights the double-encoding of the attachments field, which can cause JSON decoding issues on iOS.
* Definition of the Document model on the backend, indicating types (note `attachments` as `*string` and timestamps as `time.Time`). The JSON output of these fields must match the iOS expectations (e.g., array vs string, string vs Date).
* iOS export view model code where the response is decoded into a `Document` using `JSONDecoder`. This is the point of failure if the JSON isn’t in the expected format (e.g., an attachments string where an array is expected).
* PDF generation logic reference showing how signature URLs are used. This underscores the need for valid, accessible URLs for signatures (to include them in the PDF) but also shows that generation continues even if downloads fail, focusing our troubleshooting on JSON handling rather than PDF creation.

name: Deploy HandReceipt to Production

on:
  workflow_dispatch:
    inputs:
      deploy_frontend:
        description: 'Deploy frontend to S3/CloudFront'
        type: boolean
        default: true
      deploy_backend:
        description: 'Deploy backend to Lightsail'
        type: boolean
        default: true
      force_ip_mode:
        description: 'Force direct IP mode (bypass DNS)'
        type: boolean
        default: false
      skip_ssl_setup:
        description: 'Skip SSL certificate setup'
        type: boolean
        default: false

env:
  # S3/CloudFront Configuration
  S3_BUCKET: www.handreceipt.com
  CLOUDFRONT_DISTRIBUTION_ID: E3T7VX6HV95Q5O
  
  # Lightsail Configuration  
  LIGHTSAIL_INSTANCE_NAME: handreceipt-primary
  LIGHTSAIL_INSTANCE_IP: 44.193.254.155
  LIGHTSAIL_REGION: us-east-1
  
  # Domain Configuration
  FRONTEND_DOMAIN: handreceipt.com
  API_DOMAIN: api.handreceipt.com
  API_PORT: 8080

permissions:
  contents: read

jobs:
  detect-api-endpoint:
    name: Detect Working API Endpoint
    runs-on: ubuntu-latest
    outputs:
      api_url: ${{ steps.detect.outputs.api_url }}
      dns_working: ${{ steps.detect.outputs.dns_working }}
      ssl_working: ${{ steps.detect.outputs.ssl_working }}
    steps:
      - name: Test DNS Resolution
        id: dns_test
        run: |
          echo "Testing DNS resolution for ${{ env.API_DOMAIN }}..."
          if nslookup ${{ env.API_DOMAIN }} | grep -q "${{ env.LIGHTSAIL_INSTANCE_IP }}"; then
            echo "dns_resolved=true" >> $GITHUB_OUTPUT
            echo "‚úÖ DNS is working: ${{ env.API_DOMAIN }} ‚Üí ${{ env.LIGHTSAIL_INSTANCE_IP }}"
          else
            echo "dns_resolved=false" >> $GITHUB_OUTPUT
            echo "‚ùå DNS not working for ${{ env.API_DOMAIN }}"
          fi

      - name: Test SSL Certificate
        id: ssl_test
        if: steps.dns_test.outputs.dns_resolved == 'true'
        run: |
          echo "Testing SSL certificate for https://${{ env.API_DOMAIN }}..."
          if curl -s -f --max-time 10 https://${{ env.API_DOMAIN }}/health > /dev/null 2>&1; then
            echo "ssl_working=true" >> $GITHUB_OUTPUT
            echo "‚úÖ SSL is working"
          else
            echo "ssl_working=false" >> $GITHUB_OUTPUT
            echo "‚ùå SSL not working"
          fi

      - name: Test Direct IP Connection
        id: ip_test
        run: |
          echo "Testing direct IP connection..."
          # Try port 80 (nginx) first, then fall back to direct port 8080
          if curl -s -f --max-time 10 http://${{ env.LIGHTSAIL_INSTANCE_IP }}/health > /dev/null 2>&1; then
            echo "ip_working=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Direct IP connection working (via nginx on port 80)"
          elif curl -s -f --max-time 10 http://${{ env.LIGHTSAIL_INSTANCE_IP }}:${{ env.API_PORT }}/health > /dev/null 2>&1; then
            echo "ip_working=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Direct IP connection working (direct port 8080)"
          else
            echo "ip_working=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Direct IP connection not available (this is normal for first deployment)"
            # Don't exit with error - this might be the first deployment
          fi

      - name: Determine Best API URL
        id: detect
        run: |
          DNS_RESOLVED="${{ steps.dns_test.outputs.dns_resolved }}"
          SSL_WORKING="${{ steps.ssl_test.outputs.ssl_working }}"
          IP_WORKING="${{ steps.ip_test.outputs.ip_working }}"
          FORCE_IP="${{ inputs.force_ip_mode }}"
          
          echo "DNS_RESOLVED: $DNS_RESOLVED"
          echo "SSL_WORKING: $SSL_WORKING" 
          echo "IP_WORKING: $IP_WORKING"
          echo "FORCE_IP: $FORCE_IP"
          
          # For first deployment or when backend is being deployed, use appropriate defaults
          if [ "$FORCE_IP" = "true" ] || [ "$DNS_RESOLVED" = "false" ]; then
            # When using IP, go through nginx on port 80, not direct to app on 8080
            API_URL="http://${{ env.LIGHTSAIL_INSTANCE_IP }}/api"
            echo "üîó Using direct IP via nginx: $API_URL"
            echo "dns_working=false" >> $GITHUB_OUTPUT
            echo "ssl_working=false" >> $GITHUB_OUTPUT
          elif [ "$DNS_RESOLVED" = "true" ] && [ "$SSL_WORKING" = "true" ]; then
            API_URL="https://${{ env.API_DOMAIN }}/api"
            echo "üîí Using HTTPS with DNS: $API_URL"
            echo "dns_working=true" >> $GITHUB_OUTPUT
            echo "ssl_working=true" >> $GITHUB_OUTPUT
          elif [ "$DNS_RESOLVED" = "true" ]; then
            # DNS works but SSL not yet - this is expected for first deployment
            API_URL="https://${{ env.API_DOMAIN }}/api"
            echo "üåê Using HTTPS with DNS (SSL will be configured during deployment): $API_URL"
            echo "dns_working=true" >> $GITHUB_OUTPUT
            echo "ssl_working=false" >> $GITHUB_OUTPUT
          else
            # Fallback to IP via nginx
            API_URL="http://${{ env.LIGHTSAIL_INSTANCE_IP }}/api"
            echo "‚ö° Using direct IP via nginx (default for first deployment): $API_URL"
            echo "dns_working=false" >> $GITHUB_OUTPUT
            echo "ssl_working=false" >> $GITHUB_OUTPUT
          fi
          
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "Final API URL: $API_URL"

  build-frontend:
    name: Build Frontend
    if: ${{ inputs.deploy_frontend }}
    needs: detect-api-endpoint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: web/package-lock.json

      - name: Install Dependencies
        working-directory: ./web
        run: npm ci

      - name: Create Production Environment
        working-directory: ./web
        run: |
          echo "Creating .env.production with API URL: ${{ needs.detect-api-endpoint.outputs.api_url }}"
          cat > .env.production << EOF
          VITE_API_URL=${{ needs.detect-api-endpoint.outputs.api_url }}
          NODE_ENV=production
          VITE_BUILD_TARGET=production
          EOF
          echo "Environment file created:"
          cat .env.production

      - name: Build Frontend
        working-directory: ./web
        run: npm run build

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: web/dist/public/
          retention-days: 7

  deploy-frontend:
    name: Deploy Frontend to S3
    if: ${{ inputs.deploy_frontend }}
    needs: [detect-api-endpoint, build-frontend]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: web/dist/public/

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.LIGHTSAIL_REGION }}

      - name: Deploy to S3 with Smart Caching
        run: |
          echo "üöÄ Deploying frontend to S3..."
          
          # Create deploy directory
          mkdir -p dist_deploy
          cp -r web/dist/public/* dist_deploy/
          
          # Upload JS files with long cache
          aws s3 sync dist_deploy/ s3://${{ env.S3_BUCKET }}/ \
            --delete \
            --cache-control "max-age=31536000,public" \
            --exclude "*" \
            --include "*.js" \
            --content-type "application/javascript"
          
          # Upload CSS files with long cache
          aws s3 sync dist_deploy/ s3://${{ env.S3_BUCKET }}/ \
            --delete \
            --cache-control "max-age=31536000,public" \
            --exclude "*" \
            --include "*.css" \
            --content-type "text/css"
          
          # Upload font files
          aws s3 sync dist_deploy/ s3://${{ env.S3_BUCKET }}/ \
            --delete \
            --cache-control "max-age=31536000,public" \
            --exclude "*" \
            --include "*.woff2" \
            --content-type "font/woff2"
          
          # Upload other assets
          aws s3 sync dist_deploy/ s3://${{ env.S3_BUCKET }}/ \
            --delete \
            --cache-control "max-age=31536000,public" \
            --exclude "*.html" \
            --exclude "*.js" \
            --exclude "*.css" \
            --exclude "*.woff2"
          
          # Upload HTML with no-cache
          aws s3 sync dist_deploy/ s3://${{ env.S3_BUCKET }}/ \
            --delete \
            --cache-control "no-cache" \
            --exclude "*" \
            --include "*.html" \
            --content-type "text/html"
          
          # Clean up
          rm -rf dist_deploy

      - name: Invalidate CloudFront Cache
        run: |
          echo "üîÑ Invalidating CloudFront cache..."
          aws cloudfront create-invalidation \
            --distribution-id ${{ env.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*"

  deploy-backend:
    name: Deploy Backend to Lightsail
    if: ${{ inputs.deploy_backend }}
    needs: detect-api-endpoint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.LIGHTSAIL_REGION }}

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.LIGHTSAIL_SSH_PRIVATE_KEY }}" > ~/.ssh/lightsail_key
          chmod 600 ~/.ssh/lightsail_key
          ssh-keyscan -H ${{ env.LIGHTSAIL_INSTANCE_IP }} >> ~/.ssh/known_hosts

      - name: Deploy Backend Code
        run: |
          echo "üöÄ Deploying backend to Lightsail..."
          
          # Create deployment package in /tmp to avoid circular reference
          tar czf /tmp/deployment.tar.gz \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='web/node_modules' \
            --exclude='web/dist' \
            --exclude='.github' \
            --exclude='*.tar.gz' \
            .
          
          # Upload deployment package
          scp -i ~/.ssh/lightsail_key /tmp/deployment.tar.gz ubuntu@${{ env.LIGHTSAIL_INSTANCE_IP }}:/tmp/
          
          # Deploy on remote server
          ssh -i ~/.ssh/lightsail_key ubuntu@${{ env.LIGHTSAIL_INSTANCE_IP }} << 'EOF'
            set -e
            
            echo "üì¶ Extracting deployment package..."
            cd /opt/handreceipt
            sudo tar xzf /tmp/deployment.tar.gz --strip-components=1
            
            echo "üìÇ Current directory structure:"
            ls -la
            echo "üìÇ Backend directory structure:"
            ls -la backend/ || echo "Backend directory not found"
            
            echo "üîß Updating configurations..."
            # Ensure configs directory exists
            sudo mkdir -p backend/configs
            
            echo "üîÑ Restarting services with Docker Compose..."
            # Check if docker-compose file exists and locate it
            if [ -f "backend/docker-compose.production.yml" ]; then
              echo "‚úÖ Found docker-compose.production.yml"
              cd backend
              
              echo "üìÇ Files in backend directory:"
              ls -la
              
              # Check if Go files exist in current directory
              if [ ! -f "go.mod" ]; then
                echo "‚ùå go.mod not found in backend directory"
                exit 1
              fi
              
              if [ ! -f "go.sum" ]; then
                echo "‚ö†Ô∏è go.sum not found in backend directory, checking parent directory..."
                if [ -f "../go.sum" ]; then
                  echo "‚úÖ Found go.sum in parent directory, copying..."
                  sudo cp ../go.sum .
                else
                  echo "‚ùå go.sum not found anywhere!"
                  exit 1
                fi
              fi
              
              echo "‚úÖ All required Go files present"
              sudo cp docker-compose.production.yml docker-compose.yml
            elif [ -f "backend/docker-compose.yml" ]; then
              echo "‚úÖ Using existing docker-compose.yml"
              cd backend
            else
              echo "‚ùå No docker-compose file found!"
              echo "Looking for docker-compose files..."
              find /opt/handreceipt -name "docker-compose*.yml" -type f
              exit 1
            fi
            
            # Stop existing services
            sudo docker-compose down || true
            
            # Build and start services
            echo "Building services from directory: $(pwd)"
            echo "Docker build context contents:"
            ls -la
            
            sudo docker-compose build --no-cache app worker
            
            echo "Starting services..."
            sudo docker-compose up -d
            
            echo "‚è≥ Waiting for services to start..."
            sleep 30
            
            # Check health endpoint
            if curl -s -f http://localhost:8080/health > /dev/null 2>&1; then
              echo "‚úÖ Backend is healthy"
            else
              echo "‚ùå Backend health check failed"
              sudo docker-compose logs app
              exit 1
            fi
            
            echo "‚úÖ Backend deployment complete"
          EOF

      - name: Setup SSL Certificate
        if: ${{ needs.detect-api-endpoint.outputs.dns_working == 'true' && needs.detect-api-endpoint.outputs.ssl_working == 'false' && !github.event.inputs.skip_ssl_setup }}
        run: |
          echo "üîí Setting up SSL certificate..."
          ssh -i ~/.ssh/lightsail_key ubuntu@${{ env.LIGHTSAIL_INSTANCE_IP }} << 'EOF'
            set -e
            
            # Check if certbot is installed
            if ! command -v certbot &> /dev/null; then
              echo "Installing certbot..."
              sudo apt update
              sudo apt install -y certbot python3-certbot-nginx
            fi
            
            # Check if certificate already exists
            if sudo test -f "/etc/letsencrypt/live/${{ env.API_DOMAIN }}/fullchain.pem"; then
              echo "Certificate already exists for ${{ env.API_DOMAIN }}"
            else
              echo "Generating SSL certificate for ${{ env.API_DOMAIN }}..."
              sudo certbot --nginx -d ${{ env.API_DOMAIN }} --non-interactive --agree-tos --email noreply@handreceipt.com --redirect
            fi
            
            echo "Setting up auto-renewal..."
            sudo systemctl enable certbot.timer
            sudo systemctl start certbot.timer
            
            echo "‚úÖ SSL setup complete"
          EOF

  health-check:
    name: Post-Deployment Health Check
    needs: [detect-api-endpoint, deploy-frontend, deploy-backend]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Wait for Deployment Propagation
        run: |
          echo "‚è≥ Waiting 60 seconds for deployment to propagate..."
          sleep 60

      - name: Test Frontend Health
        if: ${{ github.event.inputs.deploy_frontend == 'true' }}
        run: |
          echo "üåê Testing frontend at https://${{ env.FRONTEND_DOMAIN }}"
          
          for i in {1..5}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.FRONTEND_DOMAIN }})
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Frontend health check passed (HTTP $HTTP_CODE)"
              break
            else
              echo "Attempt $i: Frontend returned HTTP $HTTP_CODE, retrying..."
              sleep 10
            fi
            
            if [ $i -eq 5 ]; then
              echo "‚ùå Frontend health check failed after 5 attempts"
              exit 1
            fi
          done

      - name: Test Backend Health
        if: ${{ github.event.inputs.deploy_backend == 'true' }}
        run: |
          API_URL="${{ needs.detect-api-endpoint.outputs.api_url }}"
          # Health endpoint is at /health, not under /api
          HEALTH_URL=$(echo "$API_URL" | sed 's|/api$||')/health
          echo "üîó Testing backend at $HEALTH_URL"
          
          for i in {1..5}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Backend health check passed (HTTP $HTTP_CODE)"
              break
            else
              echo "Attempt $i: Backend returned HTTP $HTTP_CODE, retrying..."
              sleep 10
            fi
            
            if [ $i -eq 5 ]; then
              echo "‚ùå Backend health check failed after 5 attempts"
              exit 1
            fi
          done

      - name: Test Frontend-Backend Integration
        if: ${{ github.event.inputs.deploy_frontend == 'true' && github.event.inputs.deploy_backend == 'true' }}
        run: |
          echo "üîÑ Testing frontend-backend integration..."
          
          # Check if frontend can reach the configured API
          FRONTEND_CONTENT=$(curl -s https://${{ env.FRONTEND_DOMAIN }} || echo "Failed to fetch frontend")
          if echo "$FRONTEND_CONTENT" | grep -q "api.handreceipt.com"; then
            echo "‚úÖ Frontend is configured with correct API URL"
          else
            echo "‚ö†Ô∏è Frontend may not be configured with the correct API URL"
          fi
          
          echo "‚úÖ Integration test complete"

      - name: DNS and SSL Status Summary
        run: |
          echo "üìã Deployment Summary:"
          echo "DNS Working: ${{ needs.detect-api-endpoint.outputs.dns_working }}"
          echo "SSL Working: ${{ needs.detect-api-endpoint.outputs.ssl_working }}"
          echo "API URL: ${{ needs.detect-api-endpoint.outputs.api_url }}"
          
          if [ "${{ needs.detect-api-endpoint.outputs.dns_working }}" = "false" ]; then
            echo "‚ö†Ô∏è DNS not working yet. To enable DNS:"
            echo "1. Verify A record: ${{ env.API_DOMAIN }} ‚Üí ${{ env.LIGHTSAIL_INSTANCE_IP }}"
            echo "2. Wait for DNS propagation (up to 24 hours)"
            echo "3. Re-run deployment with DNS working"
          fi
          
          if [ "${{ needs.detect-api-endpoint.outputs.ssl_working }}" = "false" ] && [ "${{ needs.detect-api-endpoint.outputs.dns_working }}" = "true" ]; then
            echo "‚ö†Ô∏è SSL not working yet. To enable SSL:"
            echo "1. Re-run deployment without 'skip_ssl_setup' checked"
            echo "2. Or manually run: sudo certbot --nginx -d ${{ env.API_DOMAIN }}"
          fi

  notify:
    name: Deployment Notification
    needs: [detect-api-endpoint, deploy-frontend, deploy-backend, health-check]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Deployment Success Notification
        if: ${{ needs.health-check.result == 'success' }}
        run: |
          echo "üéâ HandReceipt deployment successful!"
          echo "Frontend: https://${{ env.FRONTEND_DOMAIN }}"
          echo "API: ${{ needs.detect-api-endpoint.outputs.api_url }}"
          
          # Add Slack/Discord webhook here if desired
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"üéâ HandReceipt deployment successful!"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Deployment Failure Notification
        if: ${{ needs.health-check.result == 'failure' }}
        run: |
          echo "‚ùå HandReceipt deployment failed!"
          echo "Check the logs above for details."
          
          # Add failure notification here if desired 